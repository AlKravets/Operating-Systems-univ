# Лабораторные работы по предмету "Операционные системы"

- [Лабораторные работы по предмету "Операционные системы"](#лабораторные-работы-по-предмету-операционные-системы)
  - [Лабораторная №1 "Поставщик - Обработчик - Потребитель"](#лабораторная-1-поставщик---обработчик---потребитель)
    - [Реализация Python](#реализация-python)
      - [(Producer -> Handler -> Consumer) с использованием treading.Condition](#producer---handler---consumer-с-использованием-treadingcondition)
      - [(Producer -> Handler -> Consumer) с использованием treading.Lock](#producer---handler---consumer-с-использованием-treadinglock)
    - [Реализация C++](#реализация-c)
    - [Реализация C](#реализация-c-1)

## Лабораторная №1 "Поставщик - Обработчик - Потребитель"

У меня был вариант №4. Было дано такое условие

Реализуйте задачу по обработке информации через 1 буфер обмена, если:
- первый поток (поставщик, producer) заполняет буфер обмена данными;
- второй поток (обработчик, handler) перекодирует большие буквы текста в маленькие;
- третий поток (потребитель, consumer) записывает обработанные данные в выходной файл.

Корректно реализованная задача не приведет к изменению текста в выходном файле (по длине, по значению).

Я постарался реализовать программу на 3 разных языках
- [python source](lab1/python/ProducerHandlerConsumer.py)
- [C++ source](lab1/С++/Producer%20Handler%20Consumer.cpp)
- [C# source](lab1/C%20sharp/main.cs)

### Реализация Python

Код лежит [тут](lab1/python/ProducerHandlerConsumer.py). Я реализовал 2 варианта:

#### (Producer -> Handler -> Consumer) с использованием [treading.Condition](https://docs.python.org/3/library/threading.html#condition-objects)

Это реализовано в классе `PHC_With_Threading_Condition`. У каждого потока есть свой `threading.Condition`, и после своей итерации цикла каждый поток зависает в ожидании, пока другой поток не разбудит его.

Для создания объекта класса нужно указать:
- `producer` -  генератор, что создает данные
- `handler` - функция, что обрабатывает строки
- `consumer` - функция, что сохраняет данные
- `max_size_buffer`- ограничение для буфера. После заполнения буфера поток Producer войдет в ожидание и передаст управление потоку Handler. После работы Consumer, Producer вновь начнет работу.

#### (Producer -> Handler -> Consumer) с использованием [treading.Lock](https://docs.python.org/3/library/threading.html#lock-objects)

Это реализовано в классе `PHC_With_Three_Locks`. У каждого потока есть свой Lock. Из-за этого каждый поток блокирует сам себя после итерации цикла. Перед блокировкой поток освобождает нужный заблокированный поток, что должен продолжить работу.

Класс принимает такие же параметры, что и прошлый.

### Реализация C++

Код лежит [тут](lab1/С++/Producer%20Handler%20Consumer.cpp).

Я реализовал идею с 3 блокировками. Тут использованы mutex-ы для каждого потока. Из-за них потоки блокируют сами себя и ожидают, пока другие потоки их не освободят.

### Реализация C#

Код лежит [тут](lab1/C%20sharp/main.cs).

И вновь, тут похожая идея с блокировками. Тут использованы `AutoResetEvent` для каждого потока. После итерации цикла потока, он блокирует сам себя, пока другой поток не даст сигнал на изменение состояния `AutoResetEvent`.